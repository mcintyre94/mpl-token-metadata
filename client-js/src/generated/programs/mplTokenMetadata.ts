/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  getU8Encoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedApproveCollectionAuthorityInstruction,
  type ParsedApproveUseAuthorityInstruction,
  type ParsedBubblegumSetCollectionSizeInstruction,
  type ParsedBurnEditionNftInstruction,
  type ParsedBurnInstruction,
  type ParsedBurnNftInstruction,
  type ParsedCloseAccountsInstruction,
  type ParsedCloseEscrowAccountInstruction,
  type ParsedCollectInstruction,
  type ParsedConvertMasterEditionV1ToV2Instruction,
  type ParsedCreateEscrowAccountInstruction,
  type ParsedCreateInstruction,
  type ParsedCreateMasterEditionV3Instruction,
  type ParsedCreateMetadataAccountV3Instruction,
  type ParsedDelegateInstruction,
  type ParsedDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstruction,
  type ParsedFreezeDelegatedAccountInstruction,
  type ParsedLockInstruction,
  type ParsedMigrateInstruction,
  type ParsedMintInstruction,
  type ParsedMintNewEditionFromMasterEditionViaTokenInstruction,
  type ParsedMintNewEditionFromMasterEditionViaVaultProxyInstruction,
  type ParsedPrintInstruction,
  type ParsedPuffMetadataInstruction,
  type ParsedRemoveCreatorVerificationInstruction,
  type ParsedResizeInstruction,
  type ParsedRevokeCollectionAuthorityInstruction,
  type ParsedRevokeInstruction,
  type ParsedRevokeUseAuthorityInstruction,
  type ParsedSetAndVerifyCollectionInstruction,
  type ParsedSetAndVerifySizedCollectionItemInstruction,
  type ParsedSetCollectionSizeInstruction,
  type ParsedSetTokenStandardInstruction,
  type ParsedSignMetadataInstruction,
  type ParsedThawDelegatedAccountInstruction,
  type ParsedTransferInstruction,
  type ParsedTransferOutOfEscrowInstruction,
  type ParsedUnlockInstruction,
  type ParsedUnverifyCollectionInstruction,
  type ParsedUnverifyInstruction,
  type ParsedUnverifySizedCollectionItemInstruction,
  type ParsedUpdateInstruction,
  type ParsedUpdateMetadataAccountV2Instruction,
  type ParsedUpdatePrimarySaleHappenedViaTokenInstruction,
  type ParsedUseInstruction,
  type ParsedUtilizeInstruction,
  type ParsedVerifyCollectionInstruction,
  type ParsedVerifyInstruction,
  type ParsedVerifySizedCollectionItemInstruction,
} from '../instructions';
import { Key, getKeyEncoder } from '../types';

export const MPL_TOKEN_METADATA_PROGRAM_ADDRESS =
  'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as Address<'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'>;

export enum MplTokenMetadataAccount {
  CollectionAuthorityRecord,
  MetadataDelegateRecord,
  HolderDelegateRecord,
  Edition,
  EditionMarker,
  EditionMarkerV2,
  TokenOwnedEscrow,
  MasterEdition,
  DeprecatedMasterEditionV1,
  Metadata,
  TokenRecord,
  UseAuthorityRecord,
}

export function identifyMplTokenMetadataAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): MplTokenMetadataAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      getKeyEncoder().encode(Key.CollectionAuthorityRecord),
      0
    )
  ) {
    return MplTokenMetadataAccount.CollectionAuthorityRecord;
  }
  if (containsBytes(data, getKeyEncoder().encode(Key.EditionV1), 0)) {
    return MplTokenMetadataAccount.Edition;
  }
  if (containsBytes(data, getKeyEncoder().encode(Key.EditionMarker), 0)) {
    return MplTokenMetadataAccount.EditionMarker;
  }
  if (containsBytes(data, getKeyEncoder().encode(Key.TokenOwnedEscrow), 0)) {
    return MplTokenMetadataAccount.TokenOwnedEscrow;
  }
  if (containsBytes(data, getKeyEncoder().encode(Key.MasterEditionV2), 0)) {
    return MplTokenMetadataAccount.MasterEdition;
  }
  if (containsBytes(data, getKeyEncoder().encode(Key.MasterEditionV1), 0)) {
    return MplTokenMetadataAccount.DeprecatedMasterEditionV1;
  }
  if (containsBytes(data, getKeyEncoder().encode(Key.MetadataV1), 0)) {
    return MplTokenMetadataAccount.Metadata;
  }
  if (containsBytes(data, getKeyEncoder().encode(Key.TokenRecord), 0)) {
    return MplTokenMetadataAccount.TokenRecord;
  }
  if (containsBytes(data, getKeyEncoder().encode(Key.UseAuthorityRecord), 0)) {
    return MplTokenMetadataAccount.UseAuthorityRecord;
  }
  throw new Error(
    'The provided account could not be identified as a mplTokenMetadata account.'
  );
}

export enum MplTokenMetadataInstruction {
  DeprecatedMintNewEditionFromMasterEditionViaPrintingToken,
  UpdatePrimarySaleHappenedViaToken,
  SignMetadata,
  MintNewEditionFromMasterEditionViaToken,
  ConvertMasterEditionV1ToV2,
  MintNewEditionFromMasterEditionViaVaultProxy,
  PuffMetadata,
  UpdateMetadataAccountV2,
  CreateMasterEditionV3,
  VerifyCollection,
  Utilize,
  ApproveUseAuthority,
  RevokeUseAuthority,
  UnverifyCollection,
  ApproveCollectionAuthority,
  RevokeCollectionAuthority,
  SetAndVerifyCollection,
  FreezeDelegatedAccount,
  ThawDelegatedAccount,
  RemoveCreatorVerification,
  BurnNft,
  VerifySizedCollectionItem,
  UnverifySizedCollectionItem,
  SetAndVerifySizedCollectionItem,
  CreateMetadataAccountV3,
  SetCollectionSize,
  SetTokenStandard,
  BubblegumSetCollectionSize,
  BurnEditionNft,
  CreateEscrowAccount,
  CloseEscrowAccount,
  TransferOutOfEscrow,
  Burn,
  Create,
  Mint,
  Delegate,
  Revoke,
  Lock,
  Unlock,
  Migrate,
  Transfer,
  Update,
  Use,
  Verify,
  Unverify,
  Collect,
  Print,
  Resize,
  CloseAccounts,
}

export function identifyMplTokenMetadataInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): MplTokenMetadataInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (containsBytes(data, getU8Encoder().encode(3), 0)) {
    return MplTokenMetadataInstruction.DeprecatedMintNewEditionFromMasterEditionViaPrintingToken;
  }
  if (containsBytes(data, getU8Encoder().encode(4), 0)) {
    return MplTokenMetadataInstruction.UpdatePrimarySaleHappenedViaToken;
  }
  if (containsBytes(data, getU8Encoder().encode(7), 0)) {
    return MplTokenMetadataInstruction.SignMetadata;
  }
  if (containsBytes(data, getU8Encoder().encode(11), 0)) {
    return MplTokenMetadataInstruction.MintNewEditionFromMasterEditionViaToken;
  }
  if (containsBytes(data, getU8Encoder().encode(12), 0)) {
    return MplTokenMetadataInstruction.ConvertMasterEditionV1ToV2;
  }
  if (containsBytes(data, getU8Encoder().encode(13), 0)) {
    return MplTokenMetadataInstruction.MintNewEditionFromMasterEditionViaVaultProxy;
  }
  if (containsBytes(data, getU8Encoder().encode(14), 0)) {
    return MplTokenMetadataInstruction.PuffMetadata;
  }
  if (containsBytes(data, getU8Encoder().encode(15), 0)) {
    return MplTokenMetadataInstruction.UpdateMetadataAccountV2;
  }
  if (containsBytes(data, getU8Encoder().encode(17), 0)) {
    return MplTokenMetadataInstruction.CreateMasterEditionV3;
  }
  if (containsBytes(data, getU8Encoder().encode(18), 0)) {
    return MplTokenMetadataInstruction.VerifyCollection;
  }
  if (containsBytes(data, getU8Encoder().encode(19), 0)) {
    return MplTokenMetadataInstruction.Utilize;
  }
  if (containsBytes(data, getU8Encoder().encode(20), 0)) {
    return MplTokenMetadataInstruction.ApproveUseAuthority;
  }
  if (containsBytes(data, getU8Encoder().encode(21), 0)) {
    return MplTokenMetadataInstruction.RevokeUseAuthority;
  }
  if (containsBytes(data, getU8Encoder().encode(22), 0)) {
    return MplTokenMetadataInstruction.UnverifyCollection;
  }
  if (containsBytes(data, getU8Encoder().encode(23), 0)) {
    return MplTokenMetadataInstruction.ApproveCollectionAuthority;
  }
  if (containsBytes(data, getU8Encoder().encode(24), 0)) {
    return MplTokenMetadataInstruction.RevokeCollectionAuthority;
  }
  if (containsBytes(data, getU8Encoder().encode(25), 0)) {
    return MplTokenMetadataInstruction.SetAndVerifyCollection;
  }
  if (containsBytes(data, getU8Encoder().encode(26), 0)) {
    return MplTokenMetadataInstruction.FreezeDelegatedAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(27), 0)) {
    return MplTokenMetadataInstruction.ThawDelegatedAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(28), 0)) {
    return MplTokenMetadataInstruction.RemoveCreatorVerification;
  }
  if (containsBytes(data, getU8Encoder().encode(29), 0)) {
    return MplTokenMetadataInstruction.BurnNft;
  }
  if (containsBytes(data, getU8Encoder().encode(30), 0)) {
    return MplTokenMetadataInstruction.VerifySizedCollectionItem;
  }
  if (containsBytes(data, getU8Encoder().encode(31), 0)) {
    return MplTokenMetadataInstruction.UnverifySizedCollectionItem;
  }
  if (containsBytes(data, getU8Encoder().encode(32), 0)) {
    return MplTokenMetadataInstruction.SetAndVerifySizedCollectionItem;
  }
  if (containsBytes(data, getU8Encoder().encode(33), 0)) {
    return MplTokenMetadataInstruction.CreateMetadataAccountV3;
  }
  if (containsBytes(data, getU8Encoder().encode(34), 0)) {
    return MplTokenMetadataInstruction.SetCollectionSize;
  }
  if (containsBytes(data, getU8Encoder().encode(35), 0)) {
    return MplTokenMetadataInstruction.SetTokenStandard;
  }
  if (containsBytes(data, getU8Encoder().encode(36), 0)) {
    return MplTokenMetadataInstruction.BubblegumSetCollectionSize;
  }
  if (containsBytes(data, getU8Encoder().encode(37), 0)) {
    return MplTokenMetadataInstruction.BurnEditionNft;
  }
  if (containsBytes(data, getU8Encoder().encode(38), 0)) {
    return MplTokenMetadataInstruction.CreateEscrowAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(39), 0)) {
    return MplTokenMetadataInstruction.CloseEscrowAccount;
  }
  if (containsBytes(data, getU8Encoder().encode(40), 0)) {
    return MplTokenMetadataInstruction.TransferOutOfEscrow;
  }
  if (containsBytes(data, getU8Encoder().encode(41), 0)) {
    return MplTokenMetadataInstruction.Burn;
  }
  if (containsBytes(data, getU8Encoder().encode(42), 0)) {
    return MplTokenMetadataInstruction.Create;
  }
  if (containsBytes(data, getU8Encoder().encode(43), 0)) {
    return MplTokenMetadataInstruction.Mint;
  }
  if (containsBytes(data, getU8Encoder().encode(44), 0)) {
    return MplTokenMetadataInstruction.Delegate;
  }
  if (containsBytes(data, getU8Encoder().encode(45), 0)) {
    return MplTokenMetadataInstruction.Revoke;
  }
  if (containsBytes(data, getU8Encoder().encode(46), 0)) {
    return MplTokenMetadataInstruction.Lock;
  }
  if (containsBytes(data, getU8Encoder().encode(47), 0)) {
    return MplTokenMetadataInstruction.Unlock;
  }
  if (containsBytes(data, getU8Encoder().encode(48), 0)) {
    return MplTokenMetadataInstruction.Migrate;
  }
  if (containsBytes(data, getU8Encoder().encode(49), 0)) {
    return MplTokenMetadataInstruction.Transfer;
  }
  if (containsBytes(data, getU8Encoder().encode(50), 0)) {
    return MplTokenMetadataInstruction.Update;
  }
  if (containsBytes(data, getU8Encoder().encode(51), 0)) {
    return MplTokenMetadataInstruction.Use;
  }
  if (containsBytes(data, getU8Encoder().encode(52), 0)) {
    return MplTokenMetadataInstruction.Verify;
  }
  if (containsBytes(data, getU8Encoder().encode(53), 0)) {
    return MplTokenMetadataInstruction.Unverify;
  }
  if (containsBytes(data, getU8Encoder().encode(54), 0)) {
    return MplTokenMetadataInstruction.Collect;
  }
  if (containsBytes(data, getU8Encoder().encode(55), 0)) {
    return MplTokenMetadataInstruction.Print;
  }
  if (containsBytes(data, getU8Encoder().encode(56), 0)) {
    return MplTokenMetadataInstruction.Resize;
  }
  if (containsBytes(data, getU8Encoder().encode(57), 0)) {
    return MplTokenMetadataInstruction.CloseAccounts;
  }
  throw new Error(
    'The provided instruction could not be identified as a mplTokenMetadata instruction.'
  );
}

export type ParsedMplTokenMetadataInstruction<
  TProgram extends string = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',
> =
  | ({
      instructionType: MplTokenMetadataInstruction.DeprecatedMintNewEditionFromMasterEditionViaPrintingToken;
    } & ParsedDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.UpdatePrimarySaleHappenedViaToken;
    } & ParsedUpdatePrimarySaleHappenedViaTokenInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.SignMetadata;
    } & ParsedSignMetadataInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.MintNewEditionFromMasterEditionViaToken;
    } & ParsedMintNewEditionFromMasterEditionViaTokenInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.ConvertMasterEditionV1ToV2;
    } & ParsedConvertMasterEditionV1ToV2Instruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.MintNewEditionFromMasterEditionViaVaultProxy;
    } & ParsedMintNewEditionFromMasterEditionViaVaultProxyInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.PuffMetadata;
    } & ParsedPuffMetadataInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.UpdateMetadataAccountV2;
    } & ParsedUpdateMetadataAccountV2Instruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.CreateMasterEditionV3;
    } & ParsedCreateMasterEditionV3Instruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.VerifyCollection;
    } & ParsedVerifyCollectionInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Utilize;
    } & ParsedUtilizeInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.ApproveUseAuthority;
    } & ParsedApproveUseAuthorityInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.RevokeUseAuthority;
    } & ParsedRevokeUseAuthorityInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.UnverifyCollection;
    } & ParsedUnverifyCollectionInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.ApproveCollectionAuthority;
    } & ParsedApproveCollectionAuthorityInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.RevokeCollectionAuthority;
    } & ParsedRevokeCollectionAuthorityInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.SetAndVerifyCollection;
    } & ParsedSetAndVerifyCollectionInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.FreezeDelegatedAccount;
    } & ParsedFreezeDelegatedAccountInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.ThawDelegatedAccount;
    } & ParsedThawDelegatedAccountInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.RemoveCreatorVerification;
    } & ParsedRemoveCreatorVerificationInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.BurnNft;
    } & ParsedBurnNftInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.VerifySizedCollectionItem;
    } & ParsedVerifySizedCollectionItemInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.UnverifySizedCollectionItem;
    } & ParsedUnverifySizedCollectionItemInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.SetAndVerifySizedCollectionItem;
    } & ParsedSetAndVerifySizedCollectionItemInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.CreateMetadataAccountV3;
    } & ParsedCreateMetadataAccountV3Instruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.SetCollectionSize;
    } & ParsedSetCollectionSizeInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.SetTokenStandard;
    } & ParsedSetTokenStandardInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.BubblegumSetCollectionSize;
    } & ParsedBubblegumSetCollectionSizeInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.BurnEditionNft;
    } & ParsedBurnEditionNftInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.CreateEscrowAccount;
    } & ParsedCreateEscrowAccountInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.CloseEscrowAccount;
    } & ParsedCloseEscrowAccountInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.TransferOutOfEscrow;
    } & ParsedTransferOutOfEscrowInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Burn;
    } & ParsedBurnInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Create;
    } & ParsedCreateInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Mint;
    } & ParsedMintInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Delegate;
    } & ParsedDelegateInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Revoke;
    } & ParsedRevokeInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Lock;
    } & ParsedLockInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Unlock;
    } & ParsedUnlockInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Migrate;
    } & ParsedMigrateInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Transfer;
    } & ParsedTransferInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Update;
    } & ParsedUpdateInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Use;
    } & ParsedUseInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Verify;
    } & ParsedVerifyInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Unverify;
    } & ParsedUnverifyInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Collect;
    } & ParsedCollectInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Print;
    } & ParsedPrintInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.Resize;
    } & ParsedResizeInstruction<TProgram>)
  | ({
      instructionType: MplTokenMetadataInstruction.CloseAccounts;
    } & ParsedCloseAccountsInstruction<TProgram>);
